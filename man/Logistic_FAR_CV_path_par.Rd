% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/path_solver.R
\name{Logistic_FAR_CV_path_par}
\alias{Logistic_FAR_CV_path_par}
\title{Cross-validation for solution path of Logistic FAR.}
\usage{
Logistic_FAR_CV_path_par(
  y_vec,
  x_mat,
  h,
  kn,
  p,
  p_type,
  p_param,
  lambda_seq,
  lambda_length,
  min_lambda_ratio = 0.01,
  mu2,
  a = 1,
  bj_vec = rep(1/sqrt(kn), p),
  cj_vec = rep(1, p),
  rj_vec = 1e-05,
  weight_vec = 1,
  logit_weight_vec = 1,
  weight_already_combine = FALSE,
  relax_vec,
  delta_init,
  eta_stack_init,
  mu_1_init,
  tol,
  max_iter,
  nfold = 5,
  fold_seed,
  post_selection = FALSE,
  post_a = 1
)
}
\arguments{
\item{y_vec}{response vector, 0 for control, 1 for case.
n = length(y_vec) is the number of observations.}

\item{x_mat}{covariate matrix, consists of two parts.
dim(x_mat) = (n, h + p * kn)
First h columns are for demographical covariates(can include an intercept term)
Rest columns are for p functional covariates, each being represented by a set of basis functions resulting kn covariates.}

\item{h, kn, p}{dimension information for the dataset(\code{x_mat}).}

\item{p_type}{an character variable indicating different types of the penalty}

\item{p_param}{numerical vector for the penalty function.
\code{p_param[1]} store sthe lambda value and will be provided by \code{lambda_seq}.}

\item{lambda_seq}{a non-negative sequence of lambda, along which the solution path is searched.
It is RECOMMENED to not supply this parameter and let the function itself determines
it from the given data.}

\item{lambda_length}{length of the lambda sequence when computing \code{lambda_seq}.
If \code{lambda_seq} is provided, then of course \code{lambda_length = length(lambda_seq)}.}

\item{mu2}{quadratic term in the ADMM algorithm}

\item{a, bj_vec, cj_vec, rj_vec}{parameters for the algorithm. See Algorithm_Details.pdf
for more information.}

\item{weight_vec}{weight vector for each subject.
The final weight for each subject will be adjusted also by \code{logit_weight_vec}.
And the summation of the final weight vector is normalized to \code{n}, the sample size.}

\item{logit_weight_vec}{weight vector for each subject when computing the integral in the logit values.
Each entry should be positive and no more than 1.
This is a naive method for adjusting for early stop during the interval.}

\item{weight_already_combine}{boolen, indicating whether the \code{weight_vec}
is already combined with \code(logit_weight_vec) for each subject.}

\item{relax_vec}{not used.}

\item{delta_init, eta_stack_init, mu1_init}{initial values for the algorithm.}

\item{tol, max_iter}{convergence tolerance and max number of iteration of the algorithm.}

\item{nfold}{integer, number of folds}

\item{fold_seed}{if supplied, use this seed to generate the partitions for cross-validation.
Can be useful for reproducible runs.}

\item{post_selection}{bool, should the function also computes cross-validation results
based on post selection estimation results.}

\item{post_a}{\code{a} for the post selection estimation.}

\item{min_lam_ratio:}{\code{min(lambda_seq) / max{lambda_seq}}. This function uses this
parameter to determine the minimal value of \code{lambda_seq}. If \code{p > n}, then it
is recommended to set this no smaller than 0.01 (sometimes even 0.05), otherwise you can
set it to 0.001 or even smaller.}

\item{svd_thresh}{not used.}
}
\value{
A list containing the solution path of \code{delta}, \code{eta_stack}, \code{mu1}
and some computation information such as convergency, iteration number and the lambda
sequence of this solution path. Also information of CV is returned such as the fold ID
for each observation, the loglikelihood results on each test set and the index with the
highest average loglik on the testsets. If \code{post_selection = TRUE}, same results
based on the post selection estimation are also returned.
}
\description{
\code{Logistic_FAR_CV_path_par} finds the solution path of logistic functional
additive regression with log-contrast constrain via \code{Logistic_FAR_Path}.
And it will use cross-validation to assess the goodness of the estimations
in the solution path. The cross-validation is implemented in parallel manner.
}
\note{
Although this function will return the index of lambda given the highest
averaged loglik on the testsets. It is more recommended to use the stand alone
\code{*_pick} functions in this packages, such as \code{CV_Pick} to find a optimal
lambda since those functions give more flexibility.
}
